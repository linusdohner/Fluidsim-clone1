Du bist eine Senior-Software-Architekt:in + Fullstack-Engineer. Baue eine Desktop-App (Windows/macOS/Linux) als „FluidSIM-ähnliche“ Schaltungssimulations-Software für Pneumatik + Hydraulik + Elektro-/Digitaltechnik.\n\nZiel: Sehr ähnlicher Workflow wie FluidSIM (Baum-Komponentenbibliothek links, Zeichenfläche rechts, Eigenschaften/Parameterpanel, Simulation starten/stoppen, Messwerte/Scopes, Teileliste, Speichern/Laden). KEIN Kopieren von Markenname, Logos, Original-Icons oder proprietären Dateien. Eigene Icons/Styles erstellen, aber Interaktionslogik & Layout-Konzept sehr ähnlich.\n\n### 1) Produktumfang (MUSS)\nA) Editor / CAD\n- Unendliche Canvas, Zoom/Pan, Raster, Snap-to-grid, Fangpunkte\n- Symbole platzieren, drehen/spiegeln, gruppieren, ausrichten\n- Leitungen/Verbindungen ziehen (orthogonal, Auto-Routing optional), Knoten, T-Abzweige\n- Labeling: Bezeichner (z.B. 1V1, 1A1), freie Texte, Kommentare, Ebenen\n- Undo/Redo (beliebig), Copy/Paste, Mehrfachauswahl\n- Fehlerprüfung: unverbundene Ports, Kurzschluss, fehlende Versorgung, etc.\n\nB) Simulation\n- Simulationskern mit Zeitschritt (fixed/variable), Start/Pause/Stop, Step-by-step\n- Komponenten haben physikalische Modelle (mindestens plausibel/vereinfachtes Modell, später erweiterbar)\n- Echtzeit-Visualisierung: Zustände (Ventilstellung, Kolbenposition), Drücke/Ströme/Spannungen als Overlay\n- Messmittel: Manometer/Voltmeter/Amperemeter, Scope/Plotter, Logging\n\nC) Speichern/Laden\n- Projektformat: eigener Container (z.B. JSON oder XML + Ressourcen), versioniert, komprimierbar\n- Enthält: Diagrammgraph (Nodes/Ports/Edges), Parameter, UI-State optional, Bibliotheksreferenzen, Benutzer-Icons\n- Import/Export: PDF/PNG/SVG (Zeichnung), optional DXF (später)\n- Autosave + Crash-Recovery\n\nD) Komponentenbibliothek\n- Links: Tree View (hierarchisch, einklappbar) + Suchfeld + Favoriten\n- Jede Komponente: Symbol, Ports, Parameter (Ranges + Defaults), Kurzbeschreibung\n- Parameterpanel rechts: editierbar, mit Einheiten, Validierung\n\nE) Teileliste / Stückliste\n- Automatisch generieren (Komponenten-ID, Typ, Menge, Kommentar)\n- Export CSV/XLSX\n\n### 2) Mindest-Tech-Stack (empfohlen)\n- Desktop: Electron + React/TypeScript ODER Tauri + React/TS\n- Rendering: Canvas/WebGL (z.B. Konva/Fabric/Pixi) ODER eigene Zeichenengine\n- Simulation Engine: TypeScript (Start) + später Rust/C++ Plugin möglich\n- Datenmodell: Graph-basierte Netlist + Solver\n- Packaging: Cross-platform installer, auto-update optional\n\n### 3) Architektur (MUSS sauber & erweiterbar)\n- Domain Layer:\n  - ComponentDefinition (Ports, ParameterSchema, IconRef, ModelRef)\n  - ComponentInstance (id, transform, parameterValues)\n  - Connection (fromPort -> toPort, routing points)\n  - Project (metadata, diagram, version)\n- Simulation Layer:\n  - CompileDiagramToNetlist()\n  - Solver loop (time integration)\n  - Event system (digital signals, valve switching)\n  - Observables/telemetry for UI (plots/overlays)\n- UI Layer:\n  - LibraryPanel, CanvasEditor, PropertiesPanel, SimulationToolbar, DiagnosticsPanel, PlotPanel\n- Plugin-System:\n  - Neue Komponenten & Modelle als JSON + Model-Code registrierbar\n  - Versioning & migration scripts\n\n### 4) Funktionsliste: Komponenten-Gruppen (MUSS als Bibliotheksbaum vorhanden)\nBaue die Bibliothek mindestens in diesen Hauptgruppen auf (wie in FluidSIM 6 Component Library Übersicht):\n1) Pneumatic\n2) Hydraulic\n3) Electrical engineering / Electronics\n4) Digital components with electrical signals\n5) Electrical Controls (IEC)\n6) Electrical Controls (ANSI/NEMA)\n7) Digital technology\n8) GRAFCET\n9) Miscellaneous\n\nQuelle/Referenz zur Struktur: Die FluidSIM 6 Component Library listet genau diese Hauptgruppen und viele Untergruppen (Ventile, Aktoren, Sensoren, usw.). (Du sollst nicht kopieren, aber die Baumstruktur als Orientierung nutzen.)\n\n### 5) Konkrete Untergruppen (Minimum-V1)\nImplementiere in V1 je Bereich mindestens:\nPneumatic:\n- Supply elements (Druckluftquelle, Wartungseinheit/Filter-Regler-Öler – vereinfachtes Modell)\n- Directional valves (mechanisch/solenoid/configurable), Flow control / Shutoff valves, Pressure control valves\n- Vacuum technology (einfach)\n- Actuators (doppeltwirkender Zylinder, einfachwirkender Zylinder, Drehantrieb)\n- Sensors / measuring (Drucksensor, Endlagenschalter)\n\nHydraulic:\n- Supply elements (Pumpe, Tank, Filter)\n- Directional valves (solenoid/mechanical/configurable)\n- Flow/pressure control valves, Pressure switch\n- Actuators (Hydraulikzylinder, Motor)\n- Sensors (Druck, Durchfluss)\n\nElectrical/Electronics:\n- Power supply (24V/0V, AC/DC), Schalter/Taster\n- Passive components (R, C, L), Sicherung\n- Semiconductors (Diode, LED, Transistor – optional simpel)\n- Relais/Schütze (für IEC/ANSI Controls)\n\nDigital technology + Digital components with electrical signals:\n- AND/OR/NOT, Timer (TON/TOF), Flip-Flops, Counter\n- Ein-/Ausgänge, Sensor-Signale zu Ventilspulen\n\nGRAFCET:\n- Schritte, Transitionen, Aktionen (basic), Simulation der Schrittkettenlogik\n\nMisc:\n- Connector/Terminal, Text/Kommentar, Messpunkte, Parts list object\n\n### 6) UI/UX-Details (stark gewünscht)\n- Links Bibliothek (Tree + Search), Mitte Canvas, Rechts Eigenschaften\n- Ribbon/Toolbar: File/Edit/View/Simulation/Insert/Tools\n- Simulation: Play/Pause/Stop, Speed slider, Step\n- Statusleiste: Cursorposition, Zoom, Diagnose\n\n### 7) Roadmap (MUSS als Milestones geliefert werden)\nM1: Editor + Speichern/Laden + Library (ohne echten Solver, nur dummy state)\nM2: Pneumatik-Solver (vereinfachtes Modell) + Visualisierung\nM3: Hydraulik-Solver + Messgeräte/Plots\nM4: Elektro/Digital + Kopplung (Spule steuert Ventil)\nM5: GRAFCET + Projekt-Import/Export + Teileliste\n\n### 8) Lieferartefakte\n- Repo-Struktur + Build-Anleitung\n- Datenformat-Spezifikation (JSON/XML Schema)\n- 10 Demo-Projekte (Pneumatik, Hydraulik, Elektro-pneumatisch, GRAFCET)\n- Tests: Unit + Integration (Netlist compile, save/load, solver stability)\n- Dokumentation: „How to add a new component“ + „Modeling guide“\n\n### 9) Einschränkungen / Legal\n- Keine Verwendung von Festo/FluidSIM Namen/Logos/Originalicons\n- Keine Reverse-Engineering proprietärer Dateiformate; eigenes Format verwenden\n- Nur allgemeine Symbolik nach Normen (DIN/ISO/IEC) oder eigene Icons\n\nArbeite iterativ: Starte mit M1, liefere lauffähigen Prototypen, dann M2 usw.
